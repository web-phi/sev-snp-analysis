theory SEV_SNP_ANALYSIS begin

builtins: hashing, signing, symmetric-encryption

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////                        ////////////////////////////
////////////////////////////      RESTRICTIONS      ////////////////////////////
////////////////////////////                        ////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

restriction Unique:
"
	All x #i #j. Uniq(x) @ i & Uniq(x) @ j ==> #i = #j
"

// restriction NotEqual:
// "
// 	All x #i. Neq(x, x) @ i ==> F
// "

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////   SYSTEM   //////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

rule PageCreate:
	[
		Fr(spa)
	]
	--[
		PageCreate(spa)
	]->
	[
		RMPEntry(spa, 'HV', 'mutable', 'invalid', '0', '0'),
		PageContent(spa, '0'),
		Out(<'SPA', spa>)
	]

rule DeployGuest:
	[
		Fr(asid)
	]
	--[
		DeployGuest(asid)
	]->
	[
		!GuestID(asid),
		Out(<'ASID', asid>)
	]

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////   KEYS   ///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

rule GenerateVmpck:
	[
		!GuestID(asid),
		Fr(vmpck)
	]
	--[
		GenerateVmpck(asid, vmpck),
		Uniq(<'VMPCK', asid>),
		Uniq(vmpck)
	]->
	[
		!LTK(<'VMPCK', asid>, vmpck),
		Out(<'VMPCK', asid, h(vmpck)>)
	]

rule GenerateVek:
	[
		!GuestID(asid),
		Fr(vek)
	]
	--[
		GenerateVek(asid, vek),
		Uniq(<'VEK', asid>),
		Uniq(vek)
	]->
	[
		!LTK(<'VEK', asid>, vek),
		Out(<'VEK', asid, h(vek)>)
	]

rule GenerateOek:
	[
		!GuestID(asid),
		Fr(oek)
	]
	--[
		GenerateOek(asid, oek),
		Uniq(<'OEK', asid>),
		Uniq(oek)
	]->
	[
		!LTK(<'OEK', asid>, oek),
		Out(<'OEK', asid, h(oek)>)
	]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////   HYPERVISOR   ////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

rule HypervisorFixPage:
	[
		In(<'RMP_UPDATE', spa, 'HV', 'immutable'>),
		RMPEntry(spa, 'HV', 'mutable', 'invalid', '0', '0')
	]
	--[
		HypervisorFixPage(spa)
	]->
	[
		RMPEntry(spa, 'HV', 'immutable', 'invalid', '0', '0')
	]

rule AssignPageToGVM:
	[
		In(<'RMP_UPDATE', spa, asid>),
		!GuestID(asid),
		RMPEntry(spa, 'HV', 'mutable', 'invalid', '0', '0'),
		Fr(gpa)
	]
	--[
		RMPUpdate(spa, 'GVM', 'mutable', 'invalid', asid, gpa),
		NPTAssign(asid, gpa, spa),
		AssignPage(spa),
	]->
	[
		RMPEntry(spa, 'GVM', 'mutable', 'invalid', asid, gpa),
		NPTEntry(asid, gpa, spa),
		Out(<'GPA', gpa>)
	]

rule AssignPageToFW:
	[
		In(<'RMP_UPDATE', spa, 'FW'>),
		RMPEntry(spa, 'HV', 'mutable', 'invalid', '0', '0')
	]
	--[
		RMPUpdate(spa, 'FW', 'immutable', 'invalid', '0', '0'),
		AssignPage(spa)
	]->
	[
		RMPEntry(spa, 'FW', 'immutable', 'invalid', '0', '0')
	]

rule ReclaimPageFromGVM:
	[
		In(<'RMP_UPDATE', spa, 'HV'>),
		!GuestID(asid),
		NPTEntry(asid, gpa, spa),
		RMPEntry(spa, 'GVM', 'mutable', valid, asid, gpa)
	]
	--[
		RMPUpdate(spa, 'HV', 'mutable', 'invalid', '0', '0'),
		NPTClear(asid, gpa),
		ReclaimPage(spa)
	]->
	[
		RMPEntry(spa, 'HV', 'mutable', 'invalid', '0', '0')
	]

rule ReclaimPageFromFW:
	[
		In(<'RMP_UPDATE', spa, 'HV'>),
		RMPEntry(spa, 'FW', 'mutable', 'invalid', '0', '0')
	]
	--[
		RMPUpdate(spa, 'HV', 'mutable', 'invalid', '0', '0'),
		ReclaimPage(spa)
	]->
	[
		RMPEntry(spa, 'HV', 'mutable', 'invalid', '0', '0')
	]

rule FixGuestPage:
	[
		In(<'RMP_UPDATE', spa, asid, 'immutable'>),
		!GuestID(asid),
		RMPEntry(spa, 'GVM', 'mutable', validity, asid, gpa),
		NPTEntry(asid, gpa, spa)
	]
	--[
		RMPUpdate(spa, 'GVM', 'immutable', validity, asid, '0'),
		FixGuestPage(asid, gpa, spa),
		NPTClear(asid, gpa)
	]->
	[
		RMPEntry(spa, 'GVM', 'immutable', validity, asid, '0')
	]

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////   FIRMWARE   /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

rule FirmwareRelinquishPage:
	[
		RMPEntry(spa, 'FW', 'immutable', 'invalid', '0', '0')
	]
	--[
		RMPUpdate(spa, 'FW', 'mutable', 'invalid', '0', '0'),
		FirmwareRelinquishPage(spa)
	]->
	[
		RMPEntry(spa, 'FW', 'mutable', 'invalid', '0', '0')
	]

rule FirmwareUnfixGuestPage:
	[
		RMPEntry(spa, 'GVM', 'immutable', validity, asid, '0'),
		!GuestID(asid),
		Fr(gpa)
	]
	--[
		FirmwareUnfixGuestPage(asid, gpa, spa),
		NPTAssign(asid, gpa, spa)
	]->
	[
		RMPEntry(spa, 'GVM', 'mutable', validity, asid, gpa),
		NPTEntry(asid, gpa, spa)
	]

rule FirmwareSwapOut:
	[
		RMPEntry(spa, 'GVM', 'immutable', 'valid', asid, '0'),
		!GuestID(asid)
	]
	--[
		FirmwareSwapOut(asid, spa)
	]->
	[
		RMPEntry(spa, 'GVM', 'immutable', 'invalid', asid, '0')
	]

rule FirmwareSwapIn:
	[
		RMPEntry(spa, 'GVM', 'immutable', 'invalid', asid, '0'),
		!GuestID(asid)
	]
	--[
		FirmwareSwapIn(asid, spa)
	]->
	[
		RMPEntry(spa, 'GVM', 'immutable', 'valid', asid, '0')
	]

rule CreateGuestContextPage:
	[
		RMPEntry(spa, 'FW', 'immutable', 'invalid', '0', '0'),
		!GuestID(asid)
	]
	--[
		CreateGuestContextPage(spa, asid)
	]->
	[
		RMPEntry(spa, 'FW', 'immutable', 'invalid', asid, '0')
	]

rule DecommissionGuestContextPage:
	[
		RMPEntry(spa, 'FW', 'immutable', 'invalid', asid, '0'),
		!GuestID(asid)
	]
	--[
		DecommissionGuestContextPage(spa, asid)
	]->
	[
		RMPEntry(spa, 'FW', 'immutable', 'invalid', '0', '0')
	]

rule CreateGuestMetadataPage:
	[
		RMPEntry(spa, 'FW', 'immutable', 'invalid', '0', '0'),
		!GuestID(asid),
		In(<'GPA', gpa>)
	]
	--[
		CreateGuestMetadataPage(spa, asid, gpa),
		Neq(gpa, '0')
	]->
	[
		RMPEntry(spa, 'FW', 'immutable', 'invalid', asid, gpa)
	]

rule DecommissionGuestMetadataPage:
	[
		RMPEntry(spa, 'FW', 'immutable', 'invalid', asid, gpa),
		!GuestID(asid)
	]
	--[
		DecommissionGuestMetadataPage(spa, asid, gpa),
		Neq(gpa, '0')
	]->
	[
		RMPEntry(spa, 'FW', 'immutable', 'invalid', '0', '0')
	]


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////   GUEST VM   /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

rule GuestRequestValidation:
	let
		message = <'PAGE_VALIDATE', asid, gpa, 'valid'>
	in
	[
		!GuestID(asid),
		!LTK(<'VMPCK', asid>, vmpck),
		NPTEntry(asid, gpa, spa)
	]
	--[
		GuestSendRequest(<message, sign(message, vmpck)>)
	]->
	[
		NPTEntry(asid, gpa, spa),
		Out(<message, sign(message, vmpck)>)
	]

rule ValidateGuestPage:
	let
		message = <'PAGE_VALIDATE', asid, gpa, 'valid'>
		auth = sign(message, vmpck)
	in
	[
		!GuestID(asid),
		!LTK(<'VMPCK', asid>, vmpck),
		RMPEntry(spa, 'GVM', 'mutable', 'invalid', asid, gpa),
		In(<message, auth>)
	]
	--[
		FirmwareReceiveRequest(<message, auth>),
		ValidateGuestPage(asid, gpa, spa)
	]->
	[
		RMPEntry(spa, 'GVM', 'mutable', 'valid', asid, gpa)
	]

rule GuestRequestInvalidation:
	let
		message = <'PAGE_VALIDATE', asid, gpa, 'invalid'>
	in
	[
		!GuestID(asid),
		!LTK(<'VMPCK', asid>, vmpck),
		NPTEntry(asid, gpa, spa)
	]
	--[
		GuestSendRequest(<message, sign(message, vmpck)>)
	]->
	[
		NPTEntry(asid, gpa, spa),
		Out(<message, sign(message, vmpck)>)
	]

rule InvalidateGuestPage:
	let
		message = <'PAGE_VALIDATE', asid, gpa, 'invalid'>
		auth = sign(message, vmpck)
	in
	[
		!GuestID(asid),
		!LTK(<'VMPCK', asid>, vmpck),
		RMPEntry(spa, 'GVM', 'mutable', 'valid', asid, gpa),
		In(<message, auth>)
	]
	--[
		FirmwareReceiveRequest(<message, auth>),
		InvalidateGuestPage(asid, gpa, spa)
	]->
	[
		RMPEntry(spa, 'GVM', 'mutable', 'invalid', asid, gpa)
	]

rule GuestRequestPageWrite:
	let
		message = <'WRITE', asid, gpa, senc(content, vmpck)>
	in
	[
		!GuestID(asid),
		!LTK(<'VMPCK', asid>, vmpck),
		NPTEntry(asid, gpa, spa),
		Fr(content)
	]
	--[
		GuestSendRequest(<message, sign(message, vmpck)>)
	]->
	[
		NPTEntry(asid, gpa, spa),
		Out(<message, sign(message, vmpck)>)
	]

rule WriteToGuestPage:
	let
		message = <'WRITE', asid, gpa, senc(content, vmpck)>
		auth = sign(message, vmpck)
	in
	[
		!GuestID(asid),
		!LTK(<'VMPCK', asid>, vmpck),
		!LTK(<'VEK', asid>, vek),
		RMPEntry(spa, 'GVM', 'mutable', 'valid', asid, gpa),
		PageContent(spa, oldContent),
		In(<message, auth>)
	]
	--[
		FirmwareReceiveRequest(<message, auth>),
		WriteToGuestPage(asid, gpa, spa, content)
	]->
	[
		RMPEntry(spa, 'GVM', 'mutable', 'valid', asid, gpa),
		PageContent(spa, senc(content, vek))
	]


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////                        ////////////////////////////
////////////////////////////         LEMMAS         ////////////////////////////
////////////////////////////                        ////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

lemma Types[sources]:
"
	(All asid gpa validity auth #i.
		GuestSendRequest(<<'PAGE_VALIDATE', asid, gpa, validity>, auth>) @ i
		& (validity = 'valid' | validity = 'invalid')
	==>
		Ex spa #j. NPTAssign(asid, gpa, spa) @ j
			& j < i)
	&
	(All asid gpa content auth #i.
		GuestSendRequest(<<'WRITE', asid, gpa, content>, auth>) @ i
	==>
		Ex spa #j. NPTAssign(asid, gpa, spa) @ j
			& j < i)
"

lemma ExeHypervisorCanFixPage: exists-trace
"
	Ex spa #i. HypervisorFixPage(spa) @ i
"

lemma ExePageCanBeReclaimed: exists-trace
"
	Ex spa #i. ReclaimPage(spa) @ i
"

lemma ExePageCanBeReclaimedFromGuest: exists-trace
"
	Ex spa asid gpa #i #j.
		RMPUpdate(spa, 'GVM', 'mutable', 'invalid', asid, gpa) @ i
		& RMPUpdate(spa, 'HV', 'mutable', 'invalid', '0', '0') @ j
		& i < j
"

lemma ExePageCanBeReclaimedFromFirmware: exists-trace
"
	Ex spa #i #j.
		RMPUpdate(spa, 'FW', 'immutable', 'invalid', '0', '0') @ i
		& RMPUpdate(spa, 'HV', 'mutable', 'invalid', '0', '0') @ j
		& i < j
"

lemma ExePageCanBeAssignedToSameGuestTwice: exists-trace
"
	Ex spa asid gpa1 gpa2 #i #j.
		RMPUpdate(spa, 'GVM', 'mutable', 'invalid', asid, gpa1) @ i
		& RMPUpdate(spa, 'GVM', 'mutable', 'invalid', asid, gpa2) @ j
		& i < j
"

lemma ExeGuestPageCanBeValidated: exists-trace
"
	Ex asid gpa spa #i. ValidateGuestPage(asid, gpa, spa) @ i
"

lemma ExeGuestPageCanBeInvalidated: exists-trace
"
	Ex asid gpa spa #i. InvalidateGuestPage(asid, gpa, spa) @ i
"

lemma ExeGuestPageCanBeRevalidated: exists-trace
"
	Ex asid gpa spa #i #j.
		ValidateGuestPage(asid, gpa, spa) @ i
		& ValidateGuestPage(asid, gpa, spa) @ j
		& i < j
"

lemma ExeGuestContextPageCanBeDecommissioned: exists-trace
"
	Ex asid spa #i #j.
		CreateGuestContextPage(spa, asid) @ i
		& DecommissionGuestContextPage(spa, asid) @ j
		& i < j
"

lemma ExeContextPageCanBeCreatedForValidGuestASID: exists-trace
"
	Ex asid spa #i #j.
		DeployGuest(asid) @ i
		& CreateGuestContextPage(spa, asid) @ j
		& i < j
"

lemma ExeGuestMetadataPageCanBeDecommissioned: exists-trace
"
	Ex asid gpa spa #i #j.
		CreateGuestMetadataPage(spa, asid, gpa) @ i
		& DecommissionGuestMetadataPage(spa, asid, gpa) @ j
		& i < j
"

lemma ExeMetadataPageCanBeCreatedForValidGuestGPA: exists-trace
"
	Ex asid gpa spa1 spa2 #i #j.
		NPTAssign(asid, gpa, spa1) @ i
		& CreateGuestMetadataPage(spa2, asid, gpa) @ j
		& i < j
"

lemma ExeGuestCanWriteToPage: exists-trace
"
	Ex asid gpa spa content #i #j #k. 
		DeployGuest(asid) @ i
		& RMPUpdate(spa, 'GVM', 'mutable', 'invalid', asid, gpa) @ j
		& WriteToGuestPage(asid, gpa, spa, content) @ k
		& i < j
		& j < k
"

lemma PageCannotBeValidatedTwiceConsecutively[reuse]:
"
	All asid gpa spa #i #j.
		ValidateGuestPage(asid, gpa, spa) @ i
		& ValidateGuestPage(asid, gpa, spa) @ j
		& i < j
	==>
		Ex #k. InvalidateGuestPage(asid, gpa, spa) @ k
			& i < k
			& k < j
"

lemma ContextPageAlwaysCorrespondsToExistingGuest[reuse]:
"
	All asid spa #i.
		CreateGuestContextPage(spa, asid) @ i
	==>
		Ex #j. DeployGuest(asid) @ j
			& j < i
"

lemma GuestAddressMapsToUniqueSystemAddress[reuse]:
"
	All asid gpa spa1 spa2 #i #k.
		NPTAssign(asid, gpa, spa1) @ i
		& NPTAssign(asid, gpa, spa2) @ k
		& i < k
	==>
		Ex #j. NPTClear(asid, gpa) @ j
			& i < j
			& j < k
"

lemma SystemAddressMapsToUniqueGuestAddress[reuse]:
"
	All spa validity1 validity2 asid1 asid2 gpa1 gpa2 #i #k.
		RMPUpdate(spa, 'GVM', 'mutable', validity1, asid1, gpa1) @ i
		& RMPUpdate(spa, 'GVM', 'mutable', validity2, asid2, gpa2) @ k
		& i < k
	==>
		Ex #j. RMPUpdate(spa, 'HV', 'mutable', 'invalid', '0', '0')  @ j
			& i < j
			& j < k
"

lemma PageCanOnlyBeValidatedPerGuestRequest[reuse]:
"
	All asid gpa spa #i.
		ValidateGuestPage(asid, gpa, spa) @ i
	==>
		Ex msg vmpck #j. GuestSendRequest(<msg, sign(msg, vmpck)>) @ j
			& msg = <'PAGE_VALIDATE', asid, gpa, 'valid'>
			& j < i
			& Ex #k. GenerateVmpck(asid, vmpck) @ k
				& k < j
"

lemma PageCanOnlyBeInvalidatedPerGuestRequest[reuse]:
"
	All asid gpa spa #i.
		InvalidateGuestPage(asid, gpa, spa) @ i
	==>
		Ex msg vmpck #j. GuestSendRequest(<msg, sign(msg, vmpck)>) @ j
			& msg = <'PAGE_VALIDATE', asid, gpa, 'invalid'>
			& j < i
			& Ex #k. GenerateVmpck(asid, vmpck) @ k
				& k < j
"

lemma GuestPageCanOnlyBeWrittenToPerGuestRequest[reuse]:
"
	All asid gpa spa content #i.
		WriteToGuestPage(asid, gpa, spa, content) @ i
	==>
		Ex msg vmpck #j. GuestSendRequest(<msg, sign(msg, vmpck)>) @ j
			& msg = <'WRITE', asid, gpa, senc(content, vmpck)>
			& j < i
			& Ex #k. GenerateVmpck(asid, vmpck) @ k
				& k < j
"

end
